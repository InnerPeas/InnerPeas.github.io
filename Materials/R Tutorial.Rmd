---
title: "Introduction to R"
author: "Navid Ardeshir"
date: "9/14/2021"
output: 
  html_document
---

```{r setup, include=FALSE}
hooks = knitr::knit_hooks$get()
hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}
knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)
knitr::opts_chunk$set(echo = TRUE, fold.output = FALSE, fold.plot=FALSE)
```

## FAQ about R

- What is R?
  * R is an open source programming language which can be "easily" integrated with other programming languages, e.g. Python.
  
- Is it similar to Python?
  * Well sort of! Though, Python is fundamentally object oriented as opposed to R which is functional programming.

- How to use R?
  * All you need is an IDE (integrated developement environment) and some basic knowledge in programming (please take a look at this awesome [cheat sheet](https://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf)). I strongly suggest RStudio for those of you who haven't been exposed much to programming. 
  * RStudio environment has a LOT of features
    - Please find the help page navigator on the bottom right panel. If you were unable to find it simply run `?print` on the console and it will popup automatically.
  

## Fundamental types in R
Each value in R has a specific type which can be found by `typeof()` command:

- Character: could be a single character or a string of characters, e.g. "abcd"
- Complex: contains imaginary and real part of a complex value, e.g. 2+1i
- Numeric/Double: numerical values 
- Integer
- Logical

In addition, You can do "reasonable" operations on these types. Think of operations basically as equivalent to calling functions. Note that the output of an operation will automatically be printed out! As an exercise please read the help documentation of the function `invisible()`
```{r}
# Multiplication
2 * 3 
```

Things may go south when you combine different operations with different types:
- Same type, multiple operations: This will rise to the notion of *operator precedence*
```{r}
2 * 3 < 5
2 * 3 == 6
2 * (3 == 6)
```
- Applying one operation on different types: This will rise to automatic *type casting*
```{r}
2 + TRUE
```
One specific operator that we need is the assignment operator `->` or `<-` or `=`. Note that assignment operators won't print the value of the assignement, i.e. the operation is invisible. 
```{r}
# Variable names should start with a letter (A-Z and a-z) and can include letters, digits (0-9), dots (.), and underscores (_)
x   <- 1
x1  <- 2
x.1 <- 3
x_1 <- 2
( Total_Number_of_Students <- 143 ) 
```
## Additional important structures
There are different ways to store your data.

| Type            | Constraint  |
| :------------   | :---------- |
| Vector          | Elements should have the same type |
| Matrix          | Matching dimensions + same type |
| Data Frame      | Elements of a column should have the same type + matching dimensions |
| list            | No constraint |

## Vectors
One of the most important objects in R are vectors. Essentially vectors are a container of a collection of values (with the same type). 
```{r}
c(1,2,4)
# Example of type casting
(x <- c(1,2,4,TRUE)) ; typeof(x)
# Another example of type casting. It is crucial to know what is happening here. 
(x <- c(1,2,4,TRUE, "a")); typeof(x)
```
There are many builtin functions in R for vector manipulation and creation.

- Vector Creation:
  * colon operator `:`, e.g. 1:5 which will create c(1,2,3,4,5)
  * `seq` to create a sequence of values, e.g. seq(from = 0, to = 1, by = 0.01)
  * `rep` to create repititions of elements of a vector, e.g. rep(1, times = 10) will repeat one, ten times. 
```{r}
rep(1:2, times = 4)
rep(1:2, each = 4)
```
- Vector Manipulation
  * Most of the operations/functions are vectorized meaning they work on vectors as well, e.g. 1:3 + 2 
  * Some commonly used functions:
    - `length`, `sum`, `prod`, `min`, `pmin`, `cumsum`, `sort`, `unique`
  * Vector Slicing: how should we access elements of a vector `x`?
    - Single value extraction: `x[3]`
    - Multiple value extraction: `x[c(3,5)]`
    - Extract except these indices: `x[-c(3,5)]`
    - Extracting via a logical vector of the same length. `x[c(F,F,T,F)]` basically extracts the third element (more useful than other methods of extraction). Another example is `x[x > 0]`
    - Note that the same way you can access values, you can also assign values. `x[3] <- 10`

```{r}
x <- 1:9
# show values which are bigger than the average
x[ x > 5 ]
# extract the last element
x[length(x)]
# check summation formula
sum(x) == 9 * 10 / 2
# Assign values
x[3] <- 5
```
## Matrices
Matrix is basically a collection of vectors of the same type where each vector has the same length. Matrix can be created in the following ways:

- Passing a long vector into `matrix` function and specifying the dimensions
- Passing columns separately into `cbind`
- Passing rows separately into `rbind`
```{r}
(m <- matrix(1:12, nrow = 3, ncol=4, byrow = F)) ; dim(m)
cbind(1:2,1:2,1:2)
rbind(1:2,1:2,1:2)
```
Some Matrix manipulation tools:

- Commonly used functions
  * `t`:Transpose, e.g. `t(m)`
  * `%*%`: Matrix multiplication. becareful with the dimensions, e.g. `m %*% t(m)` 
  * `*`: Elementwise multiplication
  * `solve`: for matrix inversion and solving system of linear equations.
- Matrix Slicing: how to access elements of a matrix `m`? It is similar to vector slicing
  * Single value extraction: `m[2,3]` (second row, third column)
  * Extracting a row/column: `m[2,]` or `m[,1]`

## Data Frames
Data Frames are matrices with the additional freedom where each column can have it's own data type. 
```{r}
# Some builtin datasets
data("mtcars") ; head(mtcars)
# Data Frame creation. 
# Pass named columns. 
frame <- data.frame(column1 = 1:3, column2 = c("a","b","c"), column3 = rep(T, 3))
# Access single element
frame[2,1] ; frame$column1[2]
# Extract column
frame$column3 ; frame[ , 3] ; frame[3] ; frame[ , "column3"]
# Create and Delete a new column
frame$column4 <- c(2,3,4) ; frame$column4 <- NULL
```
## Lists 
Limits are the skies! Lists are collection of anything that you want. 
```{r}
(mylist <- list(a = 1:5, # a simple vector named a
                1:10, # a vector with different length without a name
                sum, # a function
                name = c("a","b","c"),
                L = list(a = 1, b = "b") # a list can even contain a list!
                )
)
# In order to access the elements
mylist$a ; mylist[[1]] ; mylist[["a"]]
# Note that this is different from
mylist[1] ; mylist["a"]
# Add something to the list
(mylist$new_name <- c("hello", "world"))
```

## Programming Syntax
- For loops:
  * Within the loop <span style="color: blue;">variable</span> will be assigned to an element of the <span style="color: green;">sequence</span>.
  * Inside of the for loop you can do anything you like BUT changing the value of <span style="color: blue;">variable</span>.
- Functions:
  * functions can have different arguments and names
  * Overall signature of a function looks like `function_name <- function(arg1_name = def_value_1, ... , arg_name = def_value_n) {}`. You can simply omit the default value and only specify argument name. 
  * Commands within the function closure after `return` will not be executed.
  

![Picture is from this cool [Cheat Sheet](https://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf)](/Users/navidardeshir/Desktop/intro to R/base-r-cheat-sheet.jpg) 

  
## Visualization
There are many graphical tools to plot data in R. We are going to work with `plot` function a little bit. Each call to `plot` creates a different figure where you can draw things on! 

```{r}
x <- seq(1,5,by=0.1)
par(mfrow = c(1,2))
plot(x, sin(x), type = "p", pch = 19)
plot(x, cos(x), type = "l", lwd = 2)
```
What if we wanted to overlay these plots? You should use functions such as `points` or `lines`.
```{r}
plot(x, sin(x), type = "p", pch = 19)
lines(x, cos(x), lwd = 2)
title(ylab="")
legend("topright", legend = c("sin(x)", "cos(x)"), lty = c(NA,1), pch = c(19, NA))
```


```{r}
# Notice any difference between the right and left plot?
x <- rnorm(1000)
par(mfrow = c(1,2))
hist(x, breaks = 40)
hist(x, probability=TRUE)
```

## A more practical example
Law of Large Numbers (LLN) and Central Limit Theorem (CLT). Imagine $(X_{i})_{i \le k}$ is a sequence of Bernoulli(0.5) random variable. We then take the average of the first $n$ terms for different values of $n$:
$$ Z_{n} = \frac{\sum_{j \le n}{X_j}}{n} \rightarrow 0.5 $$
In the following we show $Z_{n}$ as a function of $n$ in the range of 1 to 100. Notice that LLN guarantees $Z_{n}$ converges to 0.5 and the fluctuations are of order $\frac{1}{\sqrt{n}}$ due to CLT.
```{r}
n_simulation <- 1000
n <- 100
X <- matrix(rbinom(n_simulation * n, size = 1, prob = 0.5), nrow = n_simulation)
X.avg <- apply(X, 1, cumsum) / 1:n 

layout(rbind(rep(1,4), 2:5), heights = c(1.7,1))

matplot(1:n, X.avg, type = "l", col = "black", lty=1)
lines(1:n, X.avg[, 1], type = "l", col = "blue", lty=1, lwd =3)
lines(1:n, 0.5 + 1/sqrt(1:n), type = "l", col = "red", lty=2, lwd =3)
lines(1:n, 0.5 - 1/sqrt(1:n), type = "l", col = "red", lty=2, lwd = 3)

for(m in c(20,40,60,80)) {
  hist(X.avg[m,], probability =T, xlim=c(0.1, 0.9), ylim=c(0,8), col="blue", xlab="average", main=paste("n = ", m));
} 

```



